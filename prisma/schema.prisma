generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String    @id @default(cuid())
  name        String
  email       String    @unique
  phone       String?
  password    String
  role        String    @default("CLIENT")
  image       String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  bookings    Booking[]
  reviews     Review[]
  ownedSalons Salon[]
}

model Salon {
  id           String    @id @default(cuid())
  name         String
  description  String?
  address      String
  phone        String
  email        String?
  logo         String?
  openTime     String
  closeTime    String
  workDays     String
  active       Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  ownerId      String
  bookingType  String    @default("BOTH")
  city         String?
  coverPhoto   String?
  featured     Boolean   @default(false)
  latitude     Float?
  longitude    Float?
  photos       String[]  @default([])
  publishedAt  DateTime?
  rating       Float     @default(0)
  reviewsCount Int       @default(0)
  specialties  String[]  @default([])
  state        String?
  verified     Boolean   @default(false)
  zipCode      String?
  bookings     Booking[]
  reviews      Review[]
  owner        User      @relation(fields: [ownerId], references: [id])
  services     Service[]
  staff        Staff[]
  subscription Subscription?
}

model Staff {
  id             String         @id @default(cuid())
  name           String
  email          String?
  phone          String?
  photo          String?
  specialty      String?
  active         Boolean        @default(true)
  workDays       String?        @default("1,2,3,4,5")
  workStart      String?        @default("09:00")
  workEnd        String?        @default("18:00")
  lunchStart     String?
  lunchEnd       String?
  slotInterval   Int            @default(5)  // Intervalo entre slots em minutos
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  salonId        String
  bookings       Booking[]
  services       ServiceStaff[]
  blocks         Block[]        // Bloqueios pontuais de horário
  salon          Salon          @relation(fields: [salonId], references: [id], onDelete: Cascade)
}

model Service {
  id          String         @id @default(cuid())
  name        String
  description String?
  duration    Int
  price       Float
  category    String?
  image       String?
  active      Boolean        @default(true)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  salonId     String
  bookings    Booking[]
  salon       Salon          @relation(fields: [salonId], references: [id], onDelete: Cascade)
  staff       ServiceStaff[]
}

model ServiceStaff {
  id        String  @id @default(cuid())
  serviceId String
  staffId   String
  service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  staff     Staff   @relation(fields: [staffId], references: [id], onDelete: Cascade)

  @@unique([serviceId, staffId])
}

model Booking {
  id            String         @id @default(cuid())
  date          DateTime
  status        String         @default("PENDING")
  notes         String?
  totalPrice    Float
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  clientId      String
  salonId       String
  serviceId     String
  staffId       String
  client        User           @relation(fields: [clientId], references: [id])
  salon         Salon          @relation(fields: [salonId], references: [id], onDelete: Cascade)
  service       Service        @relation(fields: [serviceId], references: [id])
  staff         Staff          @relation(fields: [staffId], references: [id])
  notifications Notification[]
  review        Review?

  @@index([date])
  @@index([clientId])
  @@index([salonId])
}

model Notification {
  id        String    @id @default(cuid())
  type      String
  sentAt    DateTime?
  status    String    @default("PENDING")
  bookingId String
  createdAt DateTime  @default(now())
  email     String
  error     String?
  subject   String?
  booking   Booking   @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([bookingId])
  @@index([type])
  @@index([status])
}

model Review {
  id        String   @id @default(cuid())
  rating    Int
  comment   String?
  salonId   String
  userId    String
  bookingId String?  @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  booking   Booking? @relation(fields: [bookingId], references: [id])
  salon     Salon    @relation(fields: [salonId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([salonId])
  @@index([userId])
  @@index([rating])
  @@index([salonId, rating])
}

model Block {
  id        String   @id @default(cuid())
  staffId   String
  date      DateTime
  startTime String   // Formato "HH:MM"
  endTime   String   // Formato "HH:MM"
  reason    String?
  recurring Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  staff     Staff    @relation(fields: [staffId], references: [id], onDelete: Cascade)

  @@index([staffId, date])
}

// ============================================
// SUBSCRIPTION MODELS (Stripe Billing)
// ============================================

model Plan {
  id            String         @id @default(cuid())
  name          String         @unique // "Free", "Premium"
  description   String?
  price         Float          // 0.00 para Free, 39.00 para Premium
  stripePriceId String?        @unique // ID do Price no Stripe Dashboard
  features      Json           // Array de features: ["Agendamentos ilimitados", "Email support"]
  isActive      Boolean        @default(true)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  subscriptions Subscription[]
}

model Subscription {
  id                   String    @id @default(cuid())
  salonId              String    @unique // Um salão tem uma assinatura
  salon                Salon     @relation(fields: [salonId], references: [id], onDelete: Cascade)
  planId               String
  plan                 Plan      @relation(fields: [planId], references: [id])
  status               String    @default("trialing") // "trialing", "active", "past_due", "canceled", "paused"
  
  // Stripe IDs
  stripeCustomerId     String    @unique // Customer ID no Stripe
  stripeSubscriptionId String?   @unique // Subscription ID no Stripe
  
  // Trial (30 dias grátis)
  trialStartedAt       DateTime? // Quando iniciou o trial
  trialEndsAt          DateTime? // Quando termina o trial (30 dias depois)
  
  // Billing Cycle
  currentPeriodStart   DateTime  // Início do período atual de cobrança
  currentPeriodEnd     DateTime  // Fim do período atual de cobrança
  cancelAtPeriodEnd    Boolean   @default(false) // Se true, cancela ao fim do período
  canceledAt           DateTime? // Quando foi cancelado
  
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  invoices             Invoice[]

  @@index([salonId])
  @@index([status])
  @@index([stripeCustomerId])
}

model Invoice {
  id               String       @id @default(cuid())
  subscriptionId   String
  subscription     Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  amount           Float        // Valor da invoice (pode ser 0 se não cobrado)
  status           String       @default("draft") // "draft", "open", "paid", "void", "uncollectible"
  stripeInvoiceId  String?      @unique // Invoice ID no Stripe
  
  // Métricas do mês
  monthlyRevenue   Float        @default(0) // Receita do salão naquele mês (soma de bookings)
  wasCharged       Boolean      @default(true) // false se receita < R$ 1.000 (não foi cobrado)
  
  // Datas
  paidAt           DateTime? // Quando foi pago
  dueDate          DateTime  // Data de vencimento
  periodStart      DateTime  // Início do período de cobrança
  periodEnd        DateTime  // Fim do período de cobrança
  
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@index([subscriptionId])
  @@index([status])
  @@index([dueDate])
}

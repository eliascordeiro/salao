generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String           @id @default(cuid())
  name            String
  email           String           @unique
  phone           String?
  password        String
  role            String           @default("CLIENT") // "CLIENT", "ADMIN"
  roleType        String?          // "OWNER", "STAFF", "CUSTOM" (para usuários do salão)
  ownerId         String?          // ID do usuário proprietário (se for STAFF ou CUSTOM)
  permissions     String[]         @default([]) // Array de permissões ["dashboard.view", "bookings.view", etc]
  image           String?
  active          Boolean          @default(true)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  
  // Relações
  bookings        Booking[]
  reviews         Review[]
  ownedSalons     Salon[]
  cashierSessions CashierSession[]
  owner           User?            @relation("UserOwner", fields: [ownerId], references: [id])
  managedUsers    User[]           @relation("UserOwner")
  supportTickets  SupportTicket[]
  ticketMessages  TicketMessage[]
  
  @@index([ownerId])
  @@index([roleType])
}

model Salon {
  id           String    @id @default(cuid())
  name         String
  description  String?
  address      String
  phone        String
  email        String?
  logo         String?
  openTime     String
  closeTime    String
  workDays     String
  active       Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  ownerId      String
  // bookingType  String    @default("BOTH") // Temporariamente removido para Railway
  city         String?
  coverPhoto   String?
  featured     Boolean   @default(false)
  latitude     Float?
  longitude    Float?
  photos       String[]  @default([])
  publishedAt  DateTime?
  rating       Float     @default(0)
  reviewsCount Int       @default(0)
  specialties  String[]  @default([])
  state        String?
  verified     Boolean   @default(false)
  zipCode      String?
  // Campos de endereço separados
  street       String?   // Rua/Logradouro
  number       String?   // Número
  complement   String?   // Complemento (apto, sala, etc)
  neighborhood String?   // Bairro
  bookings     Booking[]
  reviews      Review[]
  owner        User      @relation(fields: [ownerId], references: [id])
  services     Service[]
  staff        Staff[]
  subscription Subscription?
  expenses     Expense[]  // Despesas do salão
}

model Staff {
  id             String         @id @default(cuid())
  name           String
  email          String?
  phone          String?
  photo          String?
  specialty      String?
  active         Boolean        @default(true)
  workDays       String?        @default("1,2,3,4,5")
  workStart      String?        @default("09:00")
  workEnd        String?        @default("18:00")
  lunchStart     String?
  lunchEnd       String?
  slotInterval   Int            @default(5)  // Intervalo entre slots em minutos
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  salonId        String
  bookings       Booking[]
  services       ServiceStaff[]
  blocks         Block[]        // Bloqueios pontuais de horário
  salon          Salon          @relation(fields: [salonId], references: [id], onDelete: Cascade)
}

model Service {
  id          String         @id @default(cuid())
  name        String
  description String?
  duration    Int
  price       Float
  category    String?
  image       String?
  active      Boolean        @default(true)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  salonId     String
  bookings    Booking[]
  salon       Salon          @relation(fields: [salonId], references: [id], onDelete: Cascade)
  staff       ServiceStaff[]
}

model ServiceStaff {
  id        String  @id @default(cuid())
  serviceId String
  staffId   String
  service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  staff     Staff   @relation(fields: [staffId], references: [id], onDelete: Cascade)

  @@unique([serviceId, staffId])
}

model Booking {
  id            String         @id @default(cuid())
  date          DateTime
  status        String         @default("PENDING")
  notes         String?
  totalPrice    Float
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  clientId      String
  salonId       String
  serviceId     String
  staffId       String
  client        User           @relation(fields: [clientId], references: [id])
  salon         Salon          @relation(fields: [salonId], references: [id], onDelete: Cascade)
  service       Service        @relation(fields: [serviceId], references: [id])
  staff         Staff          @relation(fields: [staffId], references: [id])
  notifications Notification[]
  review        Review?

  @@index([date])
  @@index([clientId])
  @@index([salonId])
}

model Notification {
  id        String    @id @default(cuid())
  type      String
  sentAt    DateTime?
  status    String    @default("PENDING")
  bookingId String
  createdAt DateTime  @default(now())
  email     String
  error     String?
  subject   String?
  booking   Booking   @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([bookingId])
  @@index([type])
  @@index([status])
}

model Review {
  id        String   @id @default(cuid())
  rating    Int
  comment   String?
  salonId   String
  userId    String
  bookingId String?  @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  booking   Booking? @relation(fields: [bookingId], references: [id])
  salon     Salon    @relation(fields: [salonId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([salonId])
  @@index([userId])
  @@index([rating])
  @@index([salonId, rating])
}

model Block {
  id        String   @id @default(cuid())
  staffId   String
  date      DateTime
  startTime String   // Formato "HH:MM"
  endTime   String   // Formato "HH:MM"
  reason    String?
  recurring Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  staff     Staff    @relation(fields: [staffId], references: [id], onDelete: Cascade)

  @@index([staffId, date])
}

// ============================================
// CASHIER / FRENTE DE CAIXA (Fechamento de Conta)
// ============================================

model CashierSession {
  id            String              @id @default(cuid())
  salonId       String
  clientId      String
  client        User                @relation(fields: [clientId], references: [id])
  
  // Totais
  subtotal      Float               // Soma dos serviços
  discount      Float               @default(0) // Desconto aplicado
  total         Float               // Subtotal - desconto
  
  // Pagamento
  status        CashierStatus       @default(OPEN)
  paymentMethod String?             // "CASH", "CARD", "PIX", "MULTIPLE"
  paidAt        DateTime?
  
  // Items da sessão (serviços prestados)
  items         CashierSessionItem[]
  
  // Timestamps
  createdAt     DateTime            @default(now())
  closedAt      DateTime?
  
  @@index([salonId])
  @@index([clientId])
  @@index([status])
  @@index([createdAt])
}

model CashierSessionItem {
  id        String          @id @default(cuid())
  sessionId String
  session   CashierSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  
  // Referência ao agendamento
  bookingId String
  
  // Snapshot do serviço no momento do fechamento
  serviceName String
  staffName   String
  price       Float
  discount    Float          @default(0)
  
  createdAt   DateTime       @default(now())
  
  @@index([sessionId])
  @@index([bookingId])
}

enum CashierStatus {
  OPEN      // Conta aberta (cliente ainda no salão)
  CLOSED    // Conta fechada (pagamento efetuado)
  CANCELLED // Cancelada
}

// Modelo de Despesas (Contas a Pagar)
model Expense {
  id          String    @id @default(cuid())
  salonId     String
  
  // Dados da despesa
  description String
  category    String    // "RENT", "UTILITIES", "PRODUCTS", "SALARIES", "MARKETING", "TAXES", "MAINTENANCE", "OTHER"
  amount      Float
  
  // Controle de pagamento
  status      String    // "PENDING", "PAID", "OVERDUE"
  dueDate     DateTime
  paidAt      DateTime?
  paymentMethod String? // "CASH", "DEBIT", "CREDIT", "PIX", "BANK_TRANSFER"
  
  // Recorrência (opcional - Fase 2)
  isRecurring    Boolean   @default(false)
  recurrence     String?   // "MONTHLY", "YEARLY", "WEEKLY"
  recurringDay   Int?      // Dia do mês (1-31) para MONTHLY, dia da semana (0-6) para WEEKLY
  lastGenerated  DateTime? // Última vez que uma despesa recorrente foi gerada
  parentExpenseId String?  // ID da despesa original (para despesas auto-geradas)
  
  // Observações
  notes       String?
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  salon       Salon     @relation(fields: [salonId], references: [id], onDelete: Cascade)
  
  @@index([salonId])
  @@index([status])
  @@index([dueDate])
}

// ==========================================
// SISTEMA DE SUPORTE
// ==========================================

model SupportTicket {
  id          String           @id @default(cuid())
  ticketNumber Int             @unique @default(autoincrement())
  
  // Informações do solicitante
  userId      String?         // Opcional - pode ser usuário não logado
  name        String
  email       String
  phone       String?
  
  // Dados do ticket
  subject     String
  category    String          // "TECNICO", "FATURAMENTO", "DUVIDA", "SUGESTAO", "RECLAMACAO"
  description String
  status      String          @default("OPEN") // "OPEN", "IN_PROGRESS", "RESOLVED", "CLOSED"
  priority    String          @default("MEDIUM") // "LOW", "MEDIUM", "HIGH", "URGENT"
  
  // Metadata
  assignedTo  String?         // ID do admin que está atendendo
  resolvedAt  DateTime?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  
  // Relações
  user        User?           @relation(fields: [userId], references: [id])
  messages    TicketMessage[]
  
  @@index([userId])
  @@index([status])
  @@index([category])
  @@index([createdAt])
}

model TicketMessage {
  id        String        @id @default(cuid())
  ticketId  String
  
  // Remetente
  userId    String?       // Se for admin ou usuário logado
  name      String        // Nome de quem enviou
  isStaff   Boolean       @default(false) // Se é resposta da equipe
  
  // Conteúdo
  message   String
  
  // Anexos (opcional para futuro)
  attachments String[]    @default([])
  
  createdAt DateTime      @default(now())
  
  // Relação
  ticket    SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user      User?         @relation(fields: [userId], references: [id])
  
  @@index([ticketId])
  @@index([createdAt])
}

// ==========================================
// SISTEMA DE ASSINATURAS (Mercado Pago)
// ==========================================

model Plan {
  id            String         @id @default(cuid())
  name          String         // "Essencial", "Profissional"
  slug          String         @unique // "essencial", "profissional"
  description   String
  price         Float          // Preço mensal em reais
  
  // Limites e Features
  maxStaff      Int?           // null = ilimitado
  maxUsers      Int            @default(1) // Usuários administrativos
  features      String[]       // ["payments", "whatsapp", "reports", "expenses"]
  
  // Status
  active        Boolean        @default(true)
  
  // Metadata
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  
  // Relações
  subscriptions Subscription[]
  
  @@index([slug])
  @@index([active])
}

model Subscription {
  id                    String    @id @default(cuid())
  
  // Salão
  salonId               String    @unique // Um salão = uma assinatura
  
  // Plano
  planId                String
  
  // Mercado Pago
  mpSubscriptionId      String?   @unique // ID da assinatura no MP (se cartão recorrente)
  mpPreferenceId        String?   // ID da preferência de pagamento
  mpPaymentId           String?   // ID do último pagamento
  paymentMethod         String    // "pix", "credit_card"
  
  // Status
  status                String    @default("PENDING") // "PENDING", "ACTIVE", "CANCELED", "EXPIRED", "SUSPENDED"
  
  // Datas
  startDate             DateTime?
  endDate               DateTime?
  nextBillingDate       DateTime?
  canceledAt            DateTime?
  
  // Histórico de pagamentos
  lastPaymentDate       DateTime?
  lastPaymentAmount     Float?
  lastPaymentStatus     String?   // "approved", "pending", "rejected"
  
  // Trial (14 dias grátis)
  trialEndsAt           DateTime?
  
  // Metadata
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  
  // Relações
  salon                 Salon     @relation(fields: [salonId], references: [id], onDelete: Cascade)
  plan                  Plan      @relation(fields: [planId], references: [id])
  payments              SubscriptionPayment[]
  
  @@index([salonId])
  @@index([planId])
  @@index([status])
  @@index([nextBillingDate])
}

model SubscriptionPayment {
  id              String       @id @default(cuid())
  subscriptionId  String
  
  // Mercado Pago
  mpPaymentId     String       @unique // ID do pagamento no MP
  mpStatus        String       // "approved", "pending", "rejected", "refunded"
  mpStatusDetail  String?
  
  // Valores
  amount          Float
  currency        String       @default("BRL")
  
  // Método
  paymentMethod   String       // "pix", "credit_card", "debit_card"
  
  // Datas
  paidAt          DateTime?
  createdAt       DateTime     @default(now())
  
  // Relação
  subscription    Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  
  @@index([subscriptionId])
  @@index([mpPaymentId])
  @@index([mpStatus])
  @@index([createdAt])
}

// Schema do banco de dados para Sistema de Agendamento
// Salões & Barbearias

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Modelo de Usuário (Clientes e Administradores)
model User {
  id            String    @id @default(cuid())
  name          String
  email         String    @unique
  phone         String?
  password      String
  role          String    @default("CLIENT") // CLIENT, ADMIN, STAFF
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Relações
  bookings      Booking[]
  ownedSalons   Salon[]
  payments      Payment[]
}

// Modelo de Salão/Barbearia
model Salon {
  id          String    @id @default(cuid())
  name        String
  description String?
  address     String
  phone       String
  email       String?
  logo        String?
  openTime    String    // Ex: "09:00"
  closeTime   String    // Ex: "19:00"
  workDays    String    // Ex: "1,2,3,4,5" (Seg-Sex)
  bookingType String    @default("BOTH") // DYNAMIC, SLOT_BASED, BOTH
  active      Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  ownerId     String
  owner       User      @relation(fields: [ownerId], references: [id])
  
  // Relações
  services    Service[]
  staff       Staff[]
  bookings    Booking[]
}

// Modelo de Profissional/Barbeiro
model Staff {
  id          String    @id @default(cuid())
  name        String
  email       String?
  phone       String?
  photo       String?
  specialty   String?   // Ex: "Corte Masculino", "Coloração"
  active      Boolean   @default(true)
  
  // Horários de trabalho
  workDays    String?   @default("1,2,3,4,5") // Ex: "1,2,3,4,5,6" (0=Dom, 1=Seg, ..., 6=Sáb)
  workStart   String?   @default("09:00") // Horário de início
  workEnd     String?   @default("18:00") // Horário de término
  lunchStart  String?   // Início do almoço (opcional)
  lunchEnd    String?   // Fim do almoço (opcional)
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  salonId     String
  salon       Salon     @relation(fields: [salonId], references: [id], onDelete: Cascade)
  
  // Relações
  bookings      Booking[]
  services      ServiceStaff[]
  availabilities Availability[]
}

// Modelo de Serviço
model Service {
  id          String    @id @default(cuid())
  name        String
  description String?
  duration    Int       // Duração em minutos
  price       Float
  category    String?   // Ex: "Corte", "Barba", "Coloração"
  image       String?
  active      Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  salonId     String
  salon       Salon     @relation(fields: [salonId], references: [id], onDelete: Cascade)
  
  // Relações
  bookings    Booking[]
  staff       ServiceStaff[]
}

// Tabela de relacionamento: Quais profissionais prestam quais serviços
model ServiceStaff {
  id        String   @id @default(cuid())
  serviceId String
  staffId   String
  
  service   Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  staff     Staff    @relation(fields: [staffId], references: [id], onDelete: Cascade)
  
  @@unique([serviceId, staffId])
}

// Modelo de Agendamento
model Booking {
  id          String    @id @default(cuid())
  date        DateTime  // Data e hora do agendamento
  status      String    @default("PENDING") // PENDING, CONFIRMED, COMPLETED, CANCELLED, NO_SHOW
  notes       String?
  totalPrice  Float
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relações
  clientId    String
  client      User      @relation(fields: [clientId], references: [id])
  
  salonId     String
  salon       Salon     @relation(fields: [salonId], references: [id], onDelete: Cascade)
  
  serviceId   String
  service     Service   @relation(fields: [serviceId], references: [id])
  
  staffId     String
  staff       Staff     @relation(fields: [staffId], references: [id])
  
  // Relação com notificações
  notifications Notification[]
  
  // Relação com pagamento
  payment     Payment?
  
  @@index([date])
  @@index([clientId])
  @@index([salonId])
}

// Modelo de Notificação (histórico de emails enviados)
model Notification {
  id          String    @id @default(cuid())
  type        String    // BOOKING_CREATED, BOOKING_CONFIRMED, BOOKING_REMINDER, BOOKING_CANCELLED
  status      String    @default("PENDING") // PENDING, SENT, FAILED
  email       String    // Email do destinatário
  subject     String?   // Assunto do email
  error       String?   // Mensagem de erro se falhou
  sentAt      DateTime? // Quando foi enviado
  createdAt   DateTime  @default(now())
  
  // Relação com agendamento
  bookingId   String
  booking     Booking   @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  
  @@index([bookingId])
  @@index([type])
  @@index([status])
}

// Modelo de Pagamento
model Payment {
  id          String    @id @default(cuid())
  amount      Float     // Valor em reais
  status      String    @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED, REFUNDED, CANCELLED
  method      String?   // CREDIT_CARD, DEBIT_CARD, PIX, BOLETO
  provider    String    @default("STRIPE") // STRIPE, MERCADOPAGO, MANUAL
  currency    String    @default("BRL")
  
  // Metadados do provider (JSON)
  stripeSessionId       String?   @unique
  stripePaymentIntentId String?
  mercadopagoId         String?
  metadata              String?   // JSON com dados extras
  
  // Datas
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  paidAt      DateTime? // Quando foi confirmado
  cancelledAt DateTime? // Quando foi cancelado
  
  // Relações
  bookingId   String    @unique
  booking     Booking   @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  transactions Transaction[]
  
  @@index([status])
  @@index([provider])
  @@index([createdAt])
  @@index([userId])
}

// Modelo de Transação (histórico de tentativas)
model Transaction {
  id          String    @id @default(cuid())
  externalId  String?   // ID do provider (Stripe, MercadoPago)
  status      String    // PENDING, AUTHORIZED, CAPTURED, FAILED, REFUNDED
  amount      Float
  
  // Detalhes
  method      String?   // Método usado
  errorCode   String?   // Código de erro se falhou
  errorMessage String?  // Mensagem de erro
  
  // Metadados
  metadata    String?   // JSON com dados da transação
  
  // Datas
  createdAt   DateTime  @default(now())
  processedAt DateTime? // Quando foi processado
  
  // Relação com pagamento
  paymentId   String
  payment     Payment   @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  
  @@index([paymentId])
  @@index([status])
  @@index([externalId])
}

// Modelo de Disponibilidade/Bloqueios de Horários
model Availability {
  id          String    @id @default(cuid())
  
  // Profissional
  staffId     String
  staff       Staff     @relation(fields: [staffId], references: [id], onDelete: Cascade)
  
  // Data e horário
  date        DateTime? // Data específica (opcional - para bloqueios pontuais)
  dayOfWeek   Int?      // Dia da semana (0=Dom, 1=Seg, ..., 6=Sáb) - para horários recorrentes
  startTime   String    // Horário inicial (HH:mm)
  endTime     String    // Horário final (HH:mm)
  
  // Status
  available   Boolean   @default(true) // true = disponível, false = bloqueado
  reason      String?   // Motivo do bloqueio (opcional)
  
  // Tipo
  type        String    @default("BLOCK") // BLOCK (bloqueio), AVAILABLE (slot disponível), RECURRING (horário recorrente)
  
  // Auditoria
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  createdBy   String?   // ID do usuário que criou
  
  @@index([staffId])
  @@index([date])
  @@index([dayOfWeek])
  @@index([staffId, date])
  @@index([staffId, dayOfWeek])
}
